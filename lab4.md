## Lab 4: Sharded Key/Value Service
### 介绍
您可以根据自己的想法做一个最终项目，也可以按照这个实验。

在本实验中，您将构建一个密钥/值存储系统，该系统可以对一组副本组上的密钥进行“分片”或分区。分片是键/值对的子集；例如，所有以"a"开头的键都可能
是一个分片，所有以“ b”开头的键都可能是一个分片，等等。分片的原因是性能。每个副本组仅处理少量分片的放置和获取，并且这些组并行运行。因此,
总的系统吞吐量（每单位时间的吞吐量）与组数成正比。

分片键/值存储区将包含两个主要组成部分。首先，一组副本组。每个副本组负责一个分片。副本服务器由少数几个使用Raft来复制组的分片的服务器组成.
第二个组件是“分片主机”。分片主机决定应为每个分片提供服务的副本组。此信息称为配置。配置随时间变化。客户端咨询分片主机，以便找到密钥的副本组,
副本组咨询主机，以便找出要服务的分片。整个系统只有一个分片主机，使用Raft实施为容错服务。

分片存储系统必须能够在副本组之间转移分片.原因之一是某些组可能比其他组负载更多,因此需要移动分片以平衡负载.另一个原因是副本组可以加入并离开系统：
可以添加新的副本组以增加容量，或者可以将现有副本组脱机以进行维修或淘汰。

本实验中的主要挑战将是处理重新配置-更改分片到组的分配.在单个副本组中,所有组成员必须就何时相对于客户端“放置/添加/获取”请求进行重新配置达成一致.
例如，Put可能与重新配置大约同时出现，导致副本组不再负责持有Put密钥的分片。组中的所有副本必须就放置是否发生在重新配置之前或之后达成一致.
如果之前，看跌期权应该生效，并且分片的新所有者将看到其生效；否则，看跌期权将不会生效，客户必须在新所有者上重试。
推荐的方法是让每个副本组都使用Raft记录日志,而不仅是Puts,Appends,和Gets,还有重新配置的顺序.您将需要确保在任何时候最多有一个副本组正在为每个分片提供请求。

重新配置还需要副本组之间的交互.例如,在配置10中,组G1可能负责分片S1.在配置11中,组G2可能负责分片S1.在从10到11的重新配置期间,
G1和G2必须使用RPC将分片S1（键/值对）的内容从G1移到G2。

> note:客户端和服务器之间只能使用RPC进行交互。例如，不允许服务器的不同实例共享Go变量或文件。

> note:本实验使用“配置”来指代分片到副本组的分配。这与Raft集群成员资格更改不同。您不必实施Raft集群成员资格更改。

该实验室的常规体系结构(配置服务和一组副本组)遵循与Flat Datacenter Storage，BigTable，Spanner，FAWN，Apache HBase，Rosebud,Spinnaker等相同的常规模式。但是，这些系统在许多细节上与本实验室不同，并且通常也更加复杂和功能强大。例如，实验室并没有演化每个Raft组中的对等组。它的数据和查询模型非常简单；分片的切换速度很慢，并且不允许并发客户端访问。
> note:您的Lab4分片服务器,Lab4分片主机和Lab3 kvraft必须都使用相同的Raft实现.作为对Lab4进行评分的一部分,我们将重新运行Lab2和Lab3测试,
您在较早测试中的得分将计入您在Lab 4的总成绩中。 这些测试在您的整体Lab 4成绩中得分10分。
### 合作政策
您必须编写您在6.824中提交的所有代码,但我们作为分配的一部分提供给您的代码除外.不允许您查看其他任何人的解决方案,不允许您查看前几年的代码,
也不允许您查看其他Raft实现.您可以与其他学生讨论作业,但不能查看或复制彼此的代码.

请不要发布您的代码或将其提供给现在或将来的6.824学生。 github.com仓库默认是公开的，因此除非您将仓库设为私有，否则请不要在其中放置代码.
您可能会发现使用MIT的GitHub方便 ，但是请确保创建一个私有存储库。
### 入门
我们为您提供框架代码，并在 src / shardmaster和src / shardkv中进行测试。

要启动并运行，请执行以下命令：
```bash
$ cd ~/6.824
$ git pull
...
$ cd src/shardmaster
$ GOPATH=~/6.824
$ export GOPATH
$ go test
--- FAIL: TestBasic (0.00s)
test_test.go:11: wanted 1 groups, got 0
FAIL
exit status 1
FAIL    shardmaster     0.008s
$
```
当你完成后,实现应通过在所有测试的`src/shardmaster`目录,并在所有的人的`src/shardkv`.
### A部分：碎片大师（30分）
首先，您将在`shardmaster/server.go和client.go`中实现分片主机.完成后,您应该通过shardmaster目录中的所有测试:
```bash
$ cd ~/6.824/src/shardmaster
$ go test
Test: Basic leave/join ...
  ... Passed
Test: Historical queries ...
  ... Passed
Test: Move ...
  ... Passed
Test: Concurrent leave/join ...
  ... Passed
Test: Minimal transfers after joins ...
  ... Passed
Test: Minimal transfers after leaves ...
  ... Passed
Test: Multi-group join/leave ...
  ... Passed
Test: Concurrent multi leave/join ...
  ... Passed
Test: Minimal transfers after multijoins ...
  ... Passed
Test: Minimal transfers after multileaves ...
  ... Passed
PASS
ok  	shardmaster	13.127s
$
```
分区管理器管理一系列编号配置.每种配置都描述了一组副本组以及将碎片分配给副本组。每当需要更改此分配时,分片母版都会使用新分配创建新配置.当键/值客户端和服务器想知道当前（或过去）的配置时，请与分片管理器联系。

您的实现必须支持shardmaster / common.go中描述的RPC接口，该接口 由 Join，Leave，Move和 Query RPC组成。这些RPC旨在允许管理员（和测试）控制分片母版：添加新的副本组，消除副本组以及在副本组之间移动分片。

在加入 RPC使用由管理员添加新的副本组。它的参数是从唯一的非零副本组标识符（GID）到服务器名称列表的一组映射。shardmaster应该通过创建包括新副本组的新配置来作出反应。新配置应在整个组中将碎片尽可能平均地分配，并应移动尽可能少的碎片以实现该目标。如果SID不在当前配置中，则该分片管理器应允许其重复使用（即，应允许GID加入，然后离开，然后再次加入）。

在离开 RPC的说法是先前加入组的GID列表。碎片管理器应创建一个不包含这些组的新配置，并将这些组的碎片分配给其余组。新配置应将碎片尽可能平均地分配到各个组中，并应移动尽可能少的碎片以实现该目标。

该移动 RPC的参数是一个碎片数量和GID。分片主机应创建一个新配置，在该配置中，分片将分配给该组。Move的目的 是使我们能够测试您的软件。由于“ 加入”和“ 离开”重新平衡，因此 “跟随” 移动的“ 加入”或“ 离开”可能会取消“ 移动”。

该查询 RPC的说法是配置数量。shardmaster答复具有该编号的配置。如果该数字是-1或大于已知的最大配置数字，则分片管理器应使用最新配置进行回复。Query（-1）的结果应反映 分片大师在收到Query（-1） RPC 之前完成的每个Join，Leave或Move RPC。

第一个配置应编号为零。它不应包含任何组，并且所有分片都应分配给GID零（无效的GID）。下一个配置（为响应Join RPC而创建）应编号为1，＆c。通常，分片的数量将远多于组（即，每个组将服务多个分片），以便可以以相当精细的粒度转移负载。

> task

您的任务是实现shardmaster /目录中的client.go和server.go中 上面指定的接口 。使用实验2/3中的Raft库，您的分片大师必须具有容错能力。请注意，在对实验4进行评分时，我们将重新运行实验2和3的测试，因此请确保您未在​​Raft实现中引入错误。通过shardmaster /中的所有测试时，您已经完成了此任务。

> 提示：

从您的kvraft服务器的精简副本开始。
您应该为分片主机实现对RPC的重复客户端请求检测。shardmaster测试不会对此进行测试，但是shardkv测试稍后会在不可靠的网络上使用您的shardmaster。如果您的shardmaster没有筛选出重复的RPC，则可能无法通过shardkv测试。
Go地图是参考。如果将一个类型映射的变量分配给另一个，则两个变量都引用同一映射。因此，如果要 基于先前的配置创建新的Config，则需要创建一个新的映射对象（使用make（））并分别复制键和值。
Go竞赛检测器（go test -race）可以帮助您查找错误。

### B部分：分片键/值服务器（60分）

现在,您将构建shardkv,这是一个分片的容错键/值存储系统.您将修改shardkv/client.go,shardkv/common.go和shardkv/server.go.

每个shardkv服务器都作为副本组的一部分运行.每个副本组为某些键空间碎片提供Get,Put和Append操作,使用key2shard(),
在client.go中找到密钥所属的分片。多个副本组协作以服务完整的分片集。shardmaster服务的单个实例 将分片分配给副本组。当此分配更改时,
副本组必须彼此传递分片，同时确保客户端不会看到不一致的响应。

您的存储系统必须为使用其客户端接口的应用程序提供可线性化的接口.也就是说,对shardkv/client.go中的Clerk.Get(),Clerk.Put()和Clerk.Append()
方法的完整应用程序调用似乎必须以相同顺序影响所有副本.一个Clerk.Get()应该看到最近写入的值 认沽 / 追加到相同的密钥.即使Get和Put大约在配置更改的同时到达也必须如此。

仅当分片的Raft副本组中的大多数服务器都处于活动状态并且可以互相通信，并且可以与大多数分片主服务器通信时，才需要每个分片都取得进展.
即使某些副本组中的少数服务器已死机，暂时不可用或运行缓慢，您的实现也必须能够运行(服务于请求并能够根据需要重新配置).

shardkv服务器仅是单个副本组的成员.给定副本组中的服务器集永远不会更改.

我们为您提供client.go代码,该代码将每个RPC发送到负责RPC密钥的副本组.如果副本组说它对密钥不负责,则重试;在这种情况下,
客户端代码会向分片主机请求最新配置,然后重试.您必须修改client.go作为支持重复客户端RPC的支持的一部分,就像在kvraft实验中一样.

完成后,您的代码应通过除挑战测试以外的所有shardkv测试:
```bash
$ cd ~/6.824/src/shardkv
$ go test
Test: static shards ...
  ... Passed
Test: join then leave ...
  ... Passed
Test: snapshots, join, and leave ...
  ... Passed
Test: servers miss configuration changes...
  ... Passed
Test: concurrent puts and configuration changes...
  ... Passed
Test: more concurrent puts and configuration changes...
  ... Passed
Test: unreliable 1...
  ... Passed
Test: unreliable 2...
  ... Passed
Test: shard deletion (challenge 1) ...
  ... Passed
Test: concurrent configuration change and restart (challenge 1)...
  ... Passed
Test: unaffected shard access (challenge 2) ...
  ... Passed
Test: partial migration shard access (challenge 2) ...
  ... Passed
PASS
ok  	shardkv	206.132s
$
```
> Note:您的服务器不应调用分片主机的Join()处理程序.测试人员将在适当的时候调用Join().

> TASK: 您的首要任务是通过第一个shardkv测试.在此测试中,仅分配了一个分片,因此您的代码应与Lab 3服务器的代码非常相似.
最大的修改是让您的服务器检测配置何时发生,并开始接受其密钥与现在拥有的分片匹配的请求.

现在您的解决方案适用于静态分片情况,是时候解决配置更改问题了.您将需要让服务器监视配置更改,并在检测到配置更改时启动分片迁移过程.
如果副本组丢失了一个分片,它必须立即停止处理对该分片中的密钥的请求,并开始将该分片的数据迁移到接管所有权的副本组中。如果副本组获得一个分片,
则需要等待以便先前的所有者在接受该分片的请求之前先发送旧的分片数据.

> task

在配置更改期间实施分片迁移,确保副本组中的所有服务器都按照它们执行的操作顺序在同一点进行迁移,以便它们都接受或拒绝并发客户端请求.
在进行后续测试之前,您应该专注于通过第二项测试(“加入然后离开”)通过所有测试,直到但不包括TestDelete时,就完成了此任务.
> Note:您的服务器将需要定期轮询分片主机以了解新配置。测试期望您的代码大约每100毫秒轮询一次；多数情况下可以，但是少得多的频率可能会导致问题.

> Note:服务器将需要相互发送RPC,以便在配置更改期间传输分片.shardmaster的Config结构包含服务器名称,但是您需要labrpc.ClientEnd才能发送RPC.
您应该使用传递给StartServer()的make_end()函数 将服务器名称转换为 ClientEnd.shardkv/client.go包含执行此操作的代码.

> 提示: 

- 将代码添加到server.go中,以定期从分片管理器获取最新配置,如果接收组不负责客户端密钥的分片,则添加代码以拒绝客户端请求.您仍然应该通过第一个测试.
- 您的服务器应使用服务器不负责的密钥(即,未将分片分配给服务器组的密钥)对客户端RPC响应 ErrWrongGroup错误.在面对并发重新配置时,请确保您的Get,
Put和Append处理程序正确做出此决定。
- 一次处理一次重新配置。
- 如果测试失败，请检查gob错误(例如“ gob：类型未为接口注册...”).尽管Gob错误对于实验室来说是致命的,但Go并不认为它是致命的.
- 您需要为分片移动中的客户端请求提供最多一次的语义（重复检测）.
- 考虑一下shardkv客户端和服务器应如何处理ErrWrongGroup.如果客户端收到ErrWrongGroup，是否应该更改序列号 ？如果在执行"获取/放置"请求时返回ErrWrongGroup,
服务器是否应该更新客户端状态？
- 服务器移至新配置后，可以继续存储不再拥有的分片是可以接受的(尽管在实际系统中这很遗憾).这可能有助于简化服务器的实现。
- 当组G1在配置更改期间需要来自G2的分片时，在处理日志条目G2的哪一点将分片发送到G1无关紧要？
- 您可以在RPC请求或回复中发送整个映射，这可能有助于使分片传输的代码保持简单。
- 如果您的RPC处理程序之一在其答复中包含服务器状态一部分的映射(例如，键/值映射),则您可能会因竞争而出现bug.RPC系统必须读取地图才能将其发送给调用方,
但它没有持有覆盖地图的锁。但是，您的服务器可能会在RPC系统读取它时继续修改同一映射。解决方案是让RPC处理程序在回复中包含映射的副本。
- 如果将地图或切片放在Raft日志条目中，然后您的键/值服务器会在applyCh上看到该条目，并在键/值服务器的状态下保存对地图/切片的引用,
那么您可能会参加比赛。制作地图/切片的副本，并将副本存储在键/值服务器的状态下。竞争是在您的键/值服务器修改地图/切片与Raft在保留其日志的同时读取它之间。
- 在更改配置期间，可能需要一对组在它们之间的两个方向上移动分片。如果您看到死锁，则可能是此来源。

###无信用挑战练习
如果要构建用于生产的这样的系统,这两个功能将是必不可少的.
####　垃圾收集状态
当副本组失去分片的所有权时,该副本组应从数据库中消除丢失的密钥.保留不再拥有且不再为请求提供服务的值对它来说是浪费的.但是,这给迁移带来了一些问题.
假设我们有两个组，G1和G2，并且有一个新的配置C，它将分片S从G1移到G2.如果在过渡到C时G1从其数据库中擦除了S中的所有键,那么当G2尝试移至C时如何获得S的数据？
> challenge:使每个副本组保留旧碎片的时间不超过绝对必要的时间.即使副本组(如上面的G1)中的所有服务器崩溃,然后重新启动,您的解决方案也必须能够正常工作.
如果您通过TestChallenge1Delete和TestChallenge1Concurrent，则您已经完成了此挑战.


#### 配置更改期间的客户端请求
处理配置更改的最简单方法是禁止所有客户端操作,直到过渡完成为止.尽管从概念上讲很简单,但是这种方法在生产级系统中不可行.每当引入或取出计算机时,
这都会导致所有客户端长时间停顿。最好继续服务不受正在进行的配置更改影响的分片.
> challenge: 修改您的解决方案，以使未受影响的分片中的密钥的客户端操作在配置更改期间继续执行.通过TestChallenge2Unaffected时,您已经完成了此挑战.

尽管上面的优化是好的,但我们仍然可以做得更好.假设某些副本组G3在过渡到C时,需要来自G1的分片S1和来自G2的分片S2.我们确实希望G3一旦收到必要的状态就立即开始为碎片服务,
即使它仍在等待其他碎片.例如,如果G1断开,则G3一旦从G2接收到适当的数据.仍应开始服务于S2的请求，尽管到C的转换尚未完成.

> CHALLENGE:修改您的解决方案,以便即使副本组仍在进行中,副本组也将在副本组能够提供的那一刻开始为其提供服务.通过TestChallenge2Partial时,您已经完成了此挑战.

### 交接程序

提交之前，请最后一次运行所有测试,

另外,请注意,您的Lab 4分片服务器,Lab 4分片主机和Lab3 kvraft必须都使用相同的Raft实现.我们将重新运行实验2和实验3测试,作为对实验4进行评分的一部分.

提交之前，请仔细检查您的解决方案是否适用于：
```bash
$ go test raft/...
$ go test kvraft/...
$ go test shardmaster/...
$ go test shardkv/..
```